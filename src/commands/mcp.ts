
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Registers the EnzymeML MCP server with the specified AI client
 * 
 * This command registers the EnzymeML MCP server binary with AI clients like
 * Claude Desktop or Cursor, enabling them to interact with EnzymeML documents
 * and data through the Model Context Protocol.
 * 
 * The function reads the client's existing MCP configuration, adds the EnzymeML
 * server to it, and writes the updated configuration back to the client's
 * configuration file.
 * 
 * # Arguments
 * * `client_type` - The type of AI client to register with (Claude Desktop or Cursor)
 * 
 * # Returns
 * * `Ok(())` if the registration was successful
 * * `Err(String)` if there was an error during registration
 * 
 * # Errors
 * * Returns error if the client configuration directory cannot be created
 * * Returns error if the existing configuration cannot be read or parsed
 * * Returns error if the updated configuration cannot be written
 */
async registerMcp(clientType: ClientType) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_mcp", { clientType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if the EnzymeML MCP server is already registered with the specified AI client
 * 
 * This command checks whether the EnzymeML MCP server is already configured
 * in the specified AI client's MCP configuration file.
 * 
 * # Arguments
 * * `client_type` - The type of AI client to check (Claude Desktop or Cursor)
 * 
 * # Returns
 * * `Ok(true)` if the EnzymeML server is already registered
 * * `Ok(false)` if the EnzymeML server is not registered or config doesn't exist
 * * `Err(String)` if there was an error reading the configuration
 */
async isMcpRegistered(clientType: ClientType) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_mcp_registered", { clientType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if the MCP server binary is installed on the system
 * 
 * This command checks whether the MCP server binary exists at the expected
 * installation path in the user's configuration directory.
 * 
 * # Returns
 * * `Ok(true)` if the binary is installed
 * * `Ok(false)` if the binary is not installed
 * * `Err(String)` if there was an error checking the installation
 */
async isMcpBinaryInstalled() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_mcp_binary_installed") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
mcpInstallOutput: McpInstallOutput,
mcpInstallStatus: McpInstallStatus,
mcpRegisterOutput: McpRegisterOutput,
mcpRegisterStatus: McpRegisterStatus
}>({
mcpInstallOutput: "mcp-install-output",
mcpInstallStatus: "mcp-install-status",
mcpRegisterOutput: "mcp-register-output",
mcpRegisterStatus: "mcp-register-status"
})

/** user-defined constants **/



/** user-defined types **/

/**
 * Supported AI client types for MCP server registration
 * 
 * This enum represents the different AI clients that support the Model Context
 * Protocol and can be configured to use the EnzymeML MCP server.
 */
export type ClientType = 
/**
 * Anthropic's Claude Desktop application
 */
"ClaudeDesktop" | 
/**
 * Cursor AI code editor
 */
"Cursor"
/**
 * Event payload for MCP installation progress updates
 */
export type McpInstallOutput = { status: McpInstallStatus; output: string }
/**
 * Status enum for MCP installation events
 */
export type McpInstallStatus = "Success" | "Error" | "Output"
/**
 * Event payload for MCP registration progress updates
 */
export type McpRegisterOutput = { status: McpRegisterStatus; output: string }
/**
 * Status enum for MCP registration events
 */
export type McpRegisterStatus = "Success" | "Error" | "Output"

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
