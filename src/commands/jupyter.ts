
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Retrieves all active Jupyter Lab sessions
 * 
 * This function returns a list of all currently running Jupyter Lab sessions
 * managed by the application. Each session contains information about the
 * session ID, URL, and port number.
 * 
 * # Arguments
 * * `jupyter_state` - The shared Jupyter state containing session information
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(Vec<JupyterSessionInfo>)` with details of all active sessions
 * - `Err(String)` if the operation fails
 */
async getJupyterSessions() : Promise<Result<JupyterSessionInfo[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_jupyter_sessions") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Terminates a specific Jupyter Lab session by ID
 * 
 * This function kills the child process associated with the given session ID,
 * effectively stopping the Jupyter Lab server. The session is identified by
 * its unique string identifier. After successful termination, emits a
 * `jupyter_update` event to notify the frontend.
 * 
 * # Arguments
 * * `app_handle` - The Tauri application handle for emitting events
 * * `jupyter_state` - The shared Jupyter state managing active sessions
 * * `id` - The unique identifier of the session to terminate
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(())` if the session is terminated successfully
 * - `Err(String)` if the operation fails, containing the error message
 * 
 * # Errors
 * Returns an error if:
 * - No session with the given ID exists
 * - The child process cannot be killed
 * - The process has already been terminated
 * - Event emission fails
 */
async killJupyter(id: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("kill_jupyter", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Starts a Jupyter Lab server with optional template
 * 
 * This function spawns a new Jupyter Lab process on an available port.
 * The server is configured to run in a dedicated directory for the current
 * EnzymeML document, ensuring each document has its own workspace.
 * The directory structure follows: `~/enzymeml-suite/projects/{document_name}/`
 * 
 * If a template is specified, it will be written to the project directory
 * before starting the server (only if the file doesn't already exist).
 * 
 * # Arguments
 * * `app_handle` - Handle to the Tauri application for shell command execution
 * * `template` - Optional template name to create in the project directory
 * * `jupyter_state` - The shared Jupyter state for managing server information
 * * `enzmldoc_state` - The shared EnzymeML document state containing document metadata
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(())` if the Jupyter Lab server starts successfully
 * - `Err(String)` if the operation fails, containing the error message
 * 
 * # Errors
 * Returns an error if:
 * - The jupyter command fails to spawn
 * - Jupyter is not installed on the system
 * - Directory creation fails
 * - Template writing fails
 * - The child process cannot be managed properly
 */
async startJupyter(template: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_jupyter", { template }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Detects all available Python installations on the system
 * 
 * This function uses the python_launcher crate to find all Python executables
 * and ranks them by priority (anaconda > homebrew > others). It stores the
 * detected installations in the JupyterState and automatically selects the
 * highest priority one if no selection has been made.
 * 
 * # Arguments
 * * `jupyter_state` - The shared Jupyter state for storing detected Pythons
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(Vec<PythonInstallation>)` with all detected Python installations
 * - `Err(String)` if the operation fails
 */
async detectPythonInstallations() : Promise<Result<PythonInstallation[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("detect_python_installations") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Lists all detected Python installations
 * 
 * # Arguments
 * * `jupyter_state` - The shared Jupyter state containing detected Pythons
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(Vec<PythonInstallation>)` with all detected Python installations
 * - `Err(String)` if the operation fails
 */
async listDetectedPythons() : Promise<Result<PythonInstallation[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_detected_pythons") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets the currently selected Python installation path
 * 
 * # Arguments
 * * `jupyter_state` - The shared Jupyter state containing the selected Python
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(Option<String>)` with the selected Python path if set
 * - `Err(String)` if the operation fails
 */
async getSelectedPython() : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_selected_python") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Sets the preferred Python installation path
 * 
 * # Arguments
 * * `jupyter_state` - The shared Jupyter state to update
 * * `path` - The path to the Python executable to use
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(())` if the path is set successfully
 * - `Err(String)` if the operation fails
 */
async setSelectedPython(path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_selected_python", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Installs JupyterLab using pip with the selected Python installation
 * 
 * This function executes the `python -m pip install jupyterlab jupyter ipywidgets` command
 * using the selected Python installation to install JupyterLab and its dependencies.
 * The installation process is streamed and emits events to the frontend for real-time progress updates.
 * 
 * # Arguments
 * * `app_handle` - The Tauri application handle for executing shell commands and emitting events
 * * `jupyter_state` - The shared Jupyter state containing selected Python path
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(())` if JupyterLab is installed successfully
 * - `Err(String)` if the installation fails, containing the error message
 * 
 * # Errors
 * Returns an error if:
 * - No Python is selected
 * - The pip command cannot be executed (pip not found in PATH)
 * - The installation process fails (e.g., network issues, permission problems)
 * - JupyterLab package cannot be found or installed
 * - Insufficient disk space or system resources
 */
async installJupyterLab() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_jupyter_lab") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if JupyterLab is installed on the system
 * 
 * This function executes the `jupyter lab --version` command using the selected
 * Python installation to determine if JupyterLab is available.
 * 
 * # Arguments
 * * `app_handle` - The Tauri application handle for executing shell commands
 * * `jupyter_state` - The shared Jupyter state containing selected Python path
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(true)` if JupyterLab is installed and accessible
 * - `Ok(false)` if JupyterLab is not found or command fails
 * - `Err(String)` if the shell command cannot be executed
 */
async isJupyterLabInstalled() : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_jupyter_lab_installed") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Retrieves all Jupyter template metadata
 * 
 * This function returns a vector containing all Jupyter template metadata
 * embedded at compile time. The metadata includes the template name, description,
 * template path, repository, and category.
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(Vec<JupyterTemplate>)` with all available template metadata
 * - `Err(String)` if the operation fails
 */
async getJupyterTemplateMetadata() : Promise<Result<JupyterTemplate[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_jupyter_template_metadata") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Adds a template to the current project directory
 * 
 * This function writes a specified Jupyter template to the current project's
 * directory. The template is only written if it doesn't already exist to
 * avoid overwriting user modifications.
 * 
 * # Arguments
 * * `template_name` - The name of the template to add to the project
 * * `state` - The shared EnzymeML state containing project information
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(())` if the template is added successfully
 * - `Err(String)` if the operation fails, containing the error message
 */
async addTemplateToProject(templateName: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_template_to_project", { templateName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Opens the project folder in the system file explorer
 * 
 * This function opens the project folder in the system file explorer.
 * If the project folder does not exist, it creates it.
 * 
 * # Arguments
 * * `app_handle` - The Tauri application handle for opening the project folder
 * * `enzmldoc_state` - The shared EnzymeML document state containing document metadata
 * 
 * # Returns
 * A `Result` containing:
 * - `Ok(())` if the project folder is opened successfully
 * - `Err(String)` if the operation fails, containing the error message
 * 
 * # Errors
 * Returns an error if:
 * - The project folder does not exist
 * - The project folder cannot be created
 * - The project folder cannot be opened
 */
async openProjectFolder() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_project_folder") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
jupyterInstallOutput: JupyterInstallOutput,
jupyterInstallStatus: JupyterInstallStatus
}>({
jupyterInstallOutput: "jupyter-install-output",
jupyterInstallStatus: "jupyter-install-status"
})

/** user-defined constants **/



/** user-defined types **/

export type JupyterInstallOutput = { status: JupyterInstallStatus; output: string }
export type JupyterInstallStatus = "Success" | "Error" | "Output"
/**
 * Lightweight, serializable view of a session (omits the live child handle).
 */
export type JupyterSessionInfo = { id: string; url: string; port: number }
export type JupyterTemplate = { name: string; description: string; template_path: string; repository: string; category: string }
/**
 * Represents a detected Python installation
 */
export type PythonInstallation = { 
/**
 * Path to the Python executable
 */
path: string; 
/**
 * Version string (e.g., "3.11.5")
 */
version: string; 
/**
 * Source/type of installation (e.g., "anaconda", "homebrew", "system")
 */
source: string; 
/**
 * Priority rank (lower is better: anaconda=1, homebrew=2, others=3)
 */
priority: number }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
